#include "vector_ram.h"
#include "string.h"
#include "dbg.h"

#define IAP_START_ADDRESS		0x20000000
#define IAP_BUF_SIZE			((sizeof(cstrIap)+3) & (~3UL))
const unsigned char cstrIap[448] = {
	0xC0,0x01,0x00,0x20,0x41,0x00,0x00,0x20,0x43,0x00,0x00,0x20,0x43,0x00,0x00,0x20,		// ... A.. C.. C.. 
	0x43,0x00,0x00,0x20,0x43,0x00,0x00,0x20,0x43,0x00,0x00,0x20,0x00,0x00,0x00,0x00,		// C.. C.. C.. ....
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x43,0x00,0x00,0x20,		// ............C.. 
	0x43,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x43,0x00,0x00,0x20,0x43,0x00,0x00,0x20,		// C.. ....C.. C.. 
	0x99,0xE0,0x98,0xE0,0x4F,0xF0,0x01,0x00,0x30,0x60,0x9B,0xE0,0x4F,0xF0,0x00,0x00,		// ....O...0`..O...
	0x30,0x60,0x97,0xE0,0x00,0xF0,0x7F,0xF8,0x00,0xF0,0x77,0xF8,0x40,0xF2,0x00,0x20,		// 0`........w.@.. 
	0xC0,0xF2,0x00,0x00,0x28,0x61,0x40,0xF2,0x04,0x20,0xC0,0xF2,0x00,0x00,0x28,0x61,		// ....(a@.. ....(a
	0x40,0xF2,0x04,0x20,0xC0,0xF2,0x01,0x00,0x28,0x61,0x00,0xF0,0x20,0xF8,0xF3,0x68,		// @.. ....(a.. ..h
	0x4F,0xEA,0xC3,0x03,0x40,0xF2,0x02,0x21,0xC0,0xF2,0x01,0x01,0x0B,0x44,0x00,0xF0,		// O...@..!.....D..
	0x62,0xF8,0x00,0xF0,0x5A,0xF8,0x40,0xF2,0x02,0x22,0xC0,0xF2,0x00,0x02,0x2A,0x61,		// b...Z.@.."....*a
	0x40,0xF2,0x02,0x22,0xC0,0xF2,0x01,0x02,0x2A,0x61,0xF0,0x68,0x00,0x28,0x06,0xD0,		// @.."....*a.h.(..
	0x00,0xF0,0x4B,0xF8,0x02,0xF1,0x08,0x02,0x2A,0x61,0x9A,0x42,0xF8,0xD1,0x00,0xF0,		// ..K.....*a.B....
	0x44,0xF8,0xC3,0xE7,0xB3,0x68,0xF2,0x68,0x4F,0xEA,0xA2,0x02,0x02,0xF1,0x01,0x02,		// D....h.hO.......
	0x52,0x1E,0x00,0x2A,0xBA,0xD0,0x18,0x68,0xB0,0xF1,0xFF,0x3F,0xB2,0xD1,0x1B,0x1D,		// R..*...h...?....
	0xF6,0xE7,0x74,0x68,0xB3,0x68,0xF2,0x68,0x4F,0xEA,0xA2,0x02,0x02,0xF1,0x01,0x02,		// ..th.h.hO.......
	0x52,0x1E,0x00,0x2A,0xAA,0xD0,0x00,0xF0,0x2E,0xF8,0x00,0xF0,0x26,0xF8,0x40,0xF2,		// R..*........&.@.
	0x00,0x20,0xC0,0xF2,0x00,0x30,0x28,0x61,0x40,0xF2,0x01,0x20,0xC0,0xF2,0x00,0x30,		// . ...0(a@.. ...0
	0x28,0x61,0x20,0x68,0x18,0x60,0x24,0x1D,0x1B,0x1D,0x00,0xF0,0x16,0xF8,0x10,0xF0,		// (a h.`$.........
	0xF3,0x01,0x01,0x29,0x8E,0xD1,0xE3,0xE7,0x00,0xF0,0x1E,0xF8,0x00,0xF0,0x0D,0xF8,		// ...)............
	0x4A,0xF6,0xEC,0x20,0xC0,0xF6,0xFF,0x70,0x68,0x61,0x4A,0xF6,0xEE,0x20,0xC0,0xF6,		// J.. ...phaJ.. ..
	0xFF,0x70,0x68,0x61,0x00,0xF0,0x01,0xF8,0x80,0xE7,0xE8,0x68,0x10,0xF4,0x80,0x31,		// .pha.......h...1
	0x00,0x29,0xFA,0xD1,0x70,0x47,0x4F,0xF0,0x33,0x00,0xE8,0x60,0x70,0x47,0x13,0x48,		// .)..pGO.3..`pG.H
	0x68,0x60,0x13,0x48,0x68,0x60,0x70,0x47,0x05,0xF1,0x08,0x01,0x11,0x48,0x08,0x60,		// h`.Hh`pG.....H.`
	0x11,0x48,0x08,0x60,0x70,0x47,0x0C,0x4D,0x10,0x4E,0xFF,0xF7,0xF0,0xFF,0x4F,0xF0,		// .H.`pG.M.N....O.
	0x00,0x00,0x30,0x60,0x4F,0xF0,0x00,0x00,0x30,0x61,0x30,0x69,0x05,0x28,0x3F,0xF7,		// ..0`O...0a0i.(?.
	0x59,0xAF,0x4F,0xEA,0x40,0x00,0x87,0x44,0x00,0xBF,0xF6,0xE7,0x6F,0xE7,0x91,0xE7,		// Y.O.@..D....o...
	0x9F,0xE7,0x57,0xE7,0xC0,0xE7,0x00,0x00,0x00,0x3C,0x02,0x40,0x23,0x01,0x67,0x45,		// ..W......<.@#.gE
	0xAB,0x89,0xEF,0xCD,0x3B,0x2A,0x19,0x08,0x7F,0x6E,0x5D,0x4C,0xEC,0x01,0x00,0x20,		// ....;*...n]L... 
	
};

typedef struct _st_icinfo{
	unsigned char aucId[8];
	unsigned int uiIdLength;
	unsigned int uiPageSizeInByte;
	unsigned int uiSectorSizeInByte;
	unsigned int uiBlockSizeInByte;
	unsigned int uiChipSizeInPage;
	
	unsigned int uiReadIdParameter;
	unsigned int uiEraseParameter;
	unsigned int uiProgramParameter;
	unsigned int uiReadParameter;
	unsigned int uiUnlockParameter;
	unsigned int uiLockParameter;
	unsigned int uiBusWidth;
}IC_INFO,*PIC_INFO;

unsigned int get_last_success(const void* cvpIcInformation,unsigned int sram[VSRAM_SIZE]){
	const IC_INFO* info = (const IC_INFO*)cvpIcInformation;
	return sram[VOFS_LAST_SUCCESS]/info->uiPageSizeInByte;
}

static void PROCESS_DECLARE(command_vec_reset)
{
	//will be call before power off.
	//you should reset all IO to high impedence.
	//Add your resect code here.
	vector_reset();
}

static void PROCESS_DECLARE(command_bus_reset)
{
	//will be call after power on.
	//Add your resect code here.
	vector_run();
}

static void PROCESS_DECLARE(command_lock)
{
	const IC_INFO* info = (const IC_INFO*)vector->cvpIcInformation;
	sram[VOFS_COMMAND] = VCMD_LOCK;
	sram[VOFS_OP_CODE_METHOD] = info->uiLockParameter;
	sram[VOFS_START_ADDRESS] = 0;
	sram[VOFS_LENGTH] = info->uiChipSizeInPage*info->uiPageSizeInByte;
	sram[VOFS_ID] = *(unsigned int*)info->aucId;
}

static void PROCESS_DECLARE(command_unlock)
{
	const IC_INFO* info = (const IC_INFO*)vector->cvpIcInformation;
	sram[VOFS_COMMAND] = VCMD_UNLOCK;
	sram[VOFS_OP_CODE_METHOD] = info->uiUnlockParameter;
	sram[VOFS_START_ADDRESS] = 0;
	sram[VOFS_LENGTH] = info->uiChipSizeInPage*info->uiPageSizeInByte;
	sram[VOFS_ID] = *(unsigned int*)info->aucId;
}

static void PROCESS_DECLARE(command_initchip)
{
	write_register(0x3030,1);//fifo
	sram[VOFS_COMMAND] = VCMD_INIT_CHIP;
	sram[VOFS_START_ADDRESS] = IAP_START_ADDRESS;
	sram[VOFS_LENGTH] = IAP_BUF_SIZE;
	write_sram(0,sram,9);
	vector->ucFlag |= VEC_F_TRIGGED;
	write_fifo(0x3034,(unsigned short const*)cstrIap,IAP_BUF_SIZE/sizeof(unsigned short));
}

static void PROCESS_DECLARE(command_readid)
{
	const IC_INFO* info = (const IC_INFO*)vector->cvpIcInformation;
	sram[VOFS_COMMAND] = VCMD_READ_ID;
	sram[VOFS_OP_CODE_METHOD] = info->uiReadIdParameter;
}

static void PROCESS_DECLARE(command_erase)
{
	const IC_INFO* info = (const IC_INFO*)vector->cvpIcInformation;
	sram[VOFS_COMMAND] = VCMD_ERASE;
	sram[VOFS_OP_CODE_METHOD] = info->uiEraseParameter;
	sram[VOFS_START_ADDRESS] = vector->uiStartPage*info->uiPageSizeInByte+vector->usOffsetInPage;
	sram[VOFS_SECTOR_NUMBER] = vector->uiImageLength/info->uiSectorSizeInByte;
	sram[VOFS_SECTOR_SIZE] = info->uiSectorSizeInByte;
	sram[VOFS_ID] = *(unsigned int*)info->aucId;
}

static void PROCESS_DECLARE(command_read)
{
	const IC_INFO* info = (const IC_INFO*)vector->cvpIcInformation;
	write_register(0x3030,(vector->ucFlag & VEC_F_FIFO)?1:0);
	sram[VOFS_COMMAND] = vector->usOperation;
	sram[VOFS_OP_CODE_METHOD] = info->uiReadParameter;
	sram[VOFS_START_ADDRESS] = vector->uiStartPage*info->uiPageSizeInByte+vector->usOffsetInPage;
	sram[VOFS_LENGTH] = vector->uiImageLength;
	sram[VOFS_ID] = *(unsigned int*)info->aucId;
}

static void PROCESS_DECLARE(command_program)
{
	const IC_INFO* info = (const IC_INFO*)vector->cvpIcInformation;
	//write_register(0x3030,(vector->uiSdRamLength)?0:1);
	write_register(0x3030,(vector->ucFlag & VEC_F_FIFO)?1:0);
	sram[VOFS_COMMAND] = VCMD_PROGRAM;
	sram[VOFS_OP_CODE_METHOD] = info->uiProgramParameter;
	sram[VOFS_START_ADDRESS] = vector->uiStartPage*info->uiPageSizeInByte+vector->usOffsetInPage;
	sram[VOFS_LENGTH] = vector->uiImageLength;
	sram[VOFS_PAGE_SIZE] = info->uiPageSizeInByte;
	sram[VOFS_OP_CODE_METHOD] = info->uiProgramParameter;
	sram[VOFS_ID] = *(unsigned int*)info->aucId;
}

static void PROCESS_DECLARE(command_nre)
{
	const IC_INFO* info = (const IC_INFO*)vector->cvpIcInformation;
	write_sram(16,vector->vpParameter,vector->uiParameter/sizeof(unsigned int));
	sram[VOFS_COMMAND] = vector->usOperation;
	sram[VOFS_OP_CODE_METHOD] = info->uiProgramParameter;
	sram[VOFS_START_ADDRESS] = vector->uiStartPage*info->uiPageSizeInByte+vector->usOffsetInPage;
	sram[VOFS_LENGTH] = vector->uiImageLength;
	sram[VOFS_PAGE_SIZE] = info->uiPageSizeInByte;
	sram[VOFS_ID] = *(unsigned int*)info->aucId;
}

static BOOL CHK_RDY_DECLARE(chkrdy_readid)
{
	const IC_INFO* info = (const IC_INFO*)vector->cvpIcInformation;
	read_sram(16,sram,(min(vector->uiParameter,info->uiIdLength)+3)/sizeof(unsigned int));
	memcpy(vector->vpParameter,sram,vector->uiParameter);
	if(memcmp(vector->vpParameter,info->aucId,info->uiIdLength)){
		return FALSE;
	}
	return TRUE;
}

static BOOL CHK_RDY_DECLARE(chkrdy_verify)
{
	vector->uiImageChecksum = sram[VOFS_CHECKSUM];
	return TRUE;
}

static BOOL CHK_RDY_DECLARE(chkrdy_initchip)
{
	unsigned int val[4];
	int i,ad;
	for(ad = 0x10;ad < 0x40;ad += 0x10){
		TraceString("SRAM");
		TraceHex(ad);
		TraceString(": ");
		read_sram(ad,val,4);
		for(i=0;i<4;i++){
			TraceHex32(val[i]);
			TraceChar(' ');
		}
		TraceString("\r\n");
	}
	return TRUE;
}

const VECTOR_FUNC vector_func[16] = {
	{command_vec_reset, NULL},		//VCMD_RESET_VECTOR		0{this will be called before power off, pass or error occured}
	{command_bus_reset,NULL},		//VCMD_RESET_BUS		1
	{command_initchip, chkrdy_initchip},		//VCMD_INIT_CHIP		2
	{command_readid, chkrdy_readid},//VCMD_READ_ID			3
	{command_unlock,NULL},			//VCMD_UNLOCK			4
	{command_erase,NULL},			//VCMD_ERASE			5
	{command_read,NULL},			//VCMD_BLANK_CHECK		6
	{command_program,NULL},			//VCMD_PROGRAM			7
	{command_read,chkrdy_verify},	//VCMD_VERIFY			8
	{command_read,NULL},			//VCMD_READ				9
	{command_lock,NULL},			//VCMD_LOCK				10
	{command_nre,NULL},				//VCMD_NRE			11
	{NULL,NULL},					//VCMD_NULL			12
	{NULL,NULL},					//VCMD_NULL			13
	{NULL,NULL},					//VCMD_NULL			14
	{NULL,NULL},					//VCMD_NULL			15
};
